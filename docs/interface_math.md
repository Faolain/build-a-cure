
  - algorithm to decide when to use interface query, when to standardize to a particular interface, and when to stack interfaces to isolate variance by applying one interface to another
    - example: analyzing priority direction once you standardize to variance interface

  - algorithm to decide when its time to retire an interface:
    - when the exploit, optimization, & variance opportunities have been exhausted using all possible combinations of components & core functions, so that the interface has fulfilled its potential usage
    - if there is external system variance, another interface may develop to host the remaining variance

  - interfaces may devolve to their abstract forms once a particular implementation is fulfilled
    - type :: combination (combination of attributes)
    - priority :: direction (intent direction)
    - function :: filter order (functions as an order of filters)
    - etc for the other interfaces - which have sub-interfaces created with transforms of the original interface:
      - rule: pattern, function
      - change: change sub-interfaces like variance/potential/attribute interface
      - conceptual: problem, question, abstraction
      - structural: symmetry, shape, similarity, information, limit, metric, boundary
    - do these transforms have patterns in common?

    - the combination, direction & filter order interfaces hold more variance than their specific implementations in the semantic interface nexus
    - this implies there are other interface nexuses using those core interfaces
    - given that the core functions of a space map to the core interfaces, the space can determine this core interface nexus - derive the core functions in a space and you'll have the original interface nexus to start from
    - another example implementation of the core interface nexus:
      - combination :: network, set, cluster, dimensions
      - direction :: potential
      - filter order :: structure (filter orders map to structures that capture variance potential)

    - network: known rules of known nodes
    - interface: gaps in known rules allowing filter to be applied to objects that can occupy the gaps, to identify variance nodes
    - interfaces should produce a network when their variance is exhausted

    - examine mixed interfaces: interfaces applied on top of interfaces in various combinations to create a topology of applied filters
    - sometimes interfaces should be applied at intervals, so variance can develop in between & adjust interface order & identity as needed
    - embedding layers like parameterization have relevance for choosing interface cycle origin points

    - how would you derive core functions which map to core shapes (combine, direction) from this space?
      - this space allows:
        - freedom to interact (there's room to select between equal alternative rules, all rules are not enforced)
        - freedom to fail (interactions don't have to benefit all entities involved)
        - freedom to calculate (you can check & verify information)
        - limits on calculation (you can know some things at cost of not knowing other things)
        - limits on variance (some rules are enforced but change or assumptions can be concentrated on specific rules to change them or change their enforcement)
        - limits on structure (you can cooperate to create structure but it will decay according to system rules)
        - limits on direction (not all decisions are reversible, and some decisions limit future decision potentials)

      - can you derive the core functions/shapes (combine, direction, filter, position) from those opportunities & limits?
        - filter maps to calculation - when you calculate something, you're reducing your consumption of other information
        - interaction allows for combination
        - interaction allows for direction (choosing a path between equal alternatives)
        - freedoms allow for randomness, which leaves room for variance

      - these freedoms & limits can be framed as a set of filters (rules) which generate the core functions/shapes, which can be used to generates various interface networks, including a key generative interface like concepts

      - freedoms can be framed as gaps in limits, so the limits would represent the interface or network structure

      - there may be an optimal interface network, but allowing them to compete could be the optimal filter

      - what shape do these limits restrict? what filter is applied to another interface to leave these limits remaining, that allow core functions like combine to thrive?

        1. this could be a meta interface (the interface interface, the limit interface) but that leaves the question of the source interface open rather than resolving it

        2. there might not be a calculatable answer (the source is not measurable inside the space) or it's a cyclical answer, where other interfaces generate other interfaces

        - interfaces overlap & influence each other: structural limits form rules, which are classifiable on the function interface, as well as the type interface, structure maps to core functions, concepts map to structure

        - so the network of rules linking interfaces for a particular core interface nexus implementation may be significant, not just as a generator of the nexus but as the primary interface for variance to develop on

        - and the network of these networks may give informtion about the answer to 2